#include <cstdio>
#include <cstdlib>
#include <cmath>
#include <ctime>
#include <cstring>
#include <direct.h>
#include <random>


//--------- Change any of these parameters to match your needs----------------
#define NVARS     30			// no. of problem variables for all the tested cases
#define POPSIZE   100			// no. of individuals in pop
#define TRIALNUM  3			// no. of run times
#define NSEL	  6				// no. for tournament selection

int FUN_NUM[]={0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22};// names of the function
int MAXEVALS;					// max. no. of function evaluations for all the tested cases 所有测试案例的最大函数评估数
double ERROR=0.1;				// difference between the results and the bestknown
double PX=0.85;					// crossover rate
double PM=0.02;//15;//02;					// mutation rate
//----------------------------------------------------------------------------
double BESTKNOWN;				// best known function fitness
double gbest;					// best value in TRIALNUM runs (the minimum is the best)
double gworst;					// worst value in TRIALNUM runs (the maximum is the worst)
double lB[NVARS],uB[NVARS];		// lower and upper boundary of variables
double prob[POPSIZE+1];			// probability, used in roulette wheel selection
double sFit[POPSIZE];			// modified fitness, used in roulette wheel selection
double bestValue;				// the best result in one run
int generation;					// current generation no.
int countEval;				    // current no. of function evaluation当前函数评估的数量
int bestGen;					// generation no. of the best fitness reached in one run 在一次运行中达到最佳适配度的代数
int bestEval;					// function evaluations of the best fitness reached in one run
int trialNum;					// counter of running times
bool flagEr;					// if reach ERROR then true, otherwise false

double resultValue[TRIALNUM];	// record the results in TRIALNUM runs
int evalRecord[TRIALNUM];		// record the function evaluations for obtaining the result
int genRecord[TRIALNUM];		// record the generations for obtaining the result
int errERecord[TRIALNUM];		// record the function evaluations for obtaining the result within ERROR
int errGRecord[TRIALNUM];		// record the generations for obtaining the result within ERROR
int successCount;				// counter of succeeding obtaining the result within ERROR
int nvars;						// no. of variables in the problem
clock_t start, finish;			// clock for recording calculation speed
clock_t total_time,avg_result_time,avg_err_time;
FILE *infile,*filet,*ftotal,*oSAvg,*oSBest;// input/output files

//The 5 lines below are used for statistic output for drawing graph
int evalStep=500000;				// output intermediate result every "evalStep" function evaluations
int evalCount;					// count the number of saved intermediate results
//the size of the following mush be bigger than "MAXEVALS/evalStep"
double evalValueAvg[100000];	// compute the average of the intermediate results
double evalValueBest[100000];	// record intermediate results of the best run
double evalValueTemp[TRIALNUM][100000];//record all the intermediate results in all runs

//----------------------------------------------------------------------------
struct SOLU // SOLU(GT), an individual in the population
{
    double x[NVARS];			// a string of variables
    double fitness;				// fitness (the bigger the better)
};
struct SOLU pop[POPSIZE+1];		// popopulation
struct SOLU npop[400];			// the samples generated according to the orthogonal array
struct SOLU opoint;				// the sample generated by the orthogonal design method

//----------------------------------------------------------------------------
#include "function.h"           // include the function definitions
double (*objfunc)(SOLU *c);		// define a function pointer

//----------------------------------------------------------------------------
//retrun a random real number in [lower bound,upper bound]
double randval(double low, double high) {
    return (rand()/(double)RAND_MAX)*(high - low) + low;
}

//initialize the population
void initialize()
{
    int i, j;

    for(i=0; i<nvars; i++) {
        for(j=0; j<POPSIZE; j++) {
            //randomly initialize the variables within the feasible range
            pop[j].x[i] = randval(lB[i],uB[i]);
        }
    }
}

//evaluate the fitness values of the whole popopulation
void evaluate() {
    for(int i=0; i<POPSIZE; i++) pop[i].fitness=objfunc(&pop[i]);
}

//store the best fitness ever been found to best-so-far (pop[POPSIZE])
void keep_the_best()
{
    int i,
            j = 0;					// stores the index of the best individual
    double best=pop[0].fitness;

    for(i=1; i<POPSIZE; i++) {
        if(pop[i].fitness < best) {
            j = i;
            best = pop[i].fitness;
        }
    }

    //record the best individual in pop[POPSIZE]
    finish = clock();
    pop[POPSIZE] = pop[j];
    bestValue = pop[POPSIZE].fitness;
    bestGen = generation;		// record the best generation
    bestEval = countEval;		// record the best function evaluation

    //check whether the result satisfies the ERROR condition
    if(!flagEr && fabs(pop[POPSIZE].fitness - BESTKNOWN) < ERROR) {
        avg_err_time += finish-start;
        errGRecord[trialNum] = generation;
        errERecord[trialNum] = countEval;
        flagEr = true;
        successCount++;
    }
}

void select_r() { //roulette wheel selection 轮盘赌
    double q, resultSum = 0;
    int i,num;
    for(i=0; i<POPSIZE; i++)
//        sFit[i] = pop[i].fitness;	//you have to change this formula if fitness <0
        sFit[i]=exp(pop[i].fitness-pop[POPSIZE].fitness);	//you have to change this formula

    for(i=0; i<POPSIZE; i++)
        resultSum += sFit[i];
    for(i=0; i<POPSIZE; i++)
        prob[i] = sFit[i]/resultSum;
    for(num=0; num<POPSIZE; num++) {
        q = rand()/(double)RAND_MAX;
        resultSum = 0;
        for(i=0; i<POPSIZE; i++) {
            resultSum += prob[i];
            if(q<resultSum)
                break;
        }
        npop[num] = pop[i];
    }
    for(i=0; i<POPSIZE; i++)
        pop[i] = npop[i];
}

void select() { //tournament selection
    int i, j;
    int child[NSEL], temp;
    double max;
    for(i=0; i<POPSIZE; i++) {
        for(j=0;j<NSEL;j++)
            child[j] = rand()%POPSIZE;

        max = pop[child[0]].fitness;
        temp = child[0];
        for(j=1; j<NSEL; j++) {
            if(max<pop[child[j]].fitness) {
                max=pop[child[j]].fitness;
                temp=child[j];
            }
        }
        npop[i] = pop[temp];
    }

    for(i=0; i<POPSIZE; i++)
        pop[i] = npop[i];
}

void Xover(int one, int two)
{
    int i;
    int point; // crossover point
    double tf;

    // select crossover point
    if(nvars > 1) {
        if(nvars == 2)
            point = 1;
        else
            point =(rand()%(nvars-1)) + 1;

        for(i=0; i<point; i++) {
            tf = pop[one].x[i];
            pop[one].x[i] = pop[two].x[i];
            pop[two].x[i] = tf;
        }
    }
}

void crossover() { //one point crossover
    int i, one;
    int first = 0; // count of the number of members chosen
    double x;

    for(i=0; i<POPSIZE; i++) {
        x = rand()/(double)RAND_MAX;
        if(x < PX) {
            first++;
            if(first%2 == 0)
                Xover(one, i);
            else
                one = i;
        }
    }
}

void mutate() {
    int i, j;
    double x;

    for(i=0; i<POPSIZE; i++) {
        for(j=0; j<nvars; j++) {
            x = rand()/(double)RAND_MAX;
            if(x < PM) {
                pop[i].x[j] = randval(lB[j],uB[j]);
            }
        }
    }
}

//if a better individual is found, store it as best-so-far (pop[POPSIZE])
//else replace the worst individual with the best-so-far (pop[POPSIZE])
void elitist() {
    int i;
    double best, worst;             // best and worst fitness values
    int best_i, worst_i;		// indexes of the best and worst member

    best = pop[0].fitness;
    worst = pop[0].fitness;
    for(i=1; i<POPSIZE; i++) {
        if(pop[i-1].fitness < pop[i].fitness) {
            if(pop[i-1].fitness <= best) {
                best = pop[i-1].fitness;
                best_i = i-1;
            }
            if (pop[i].fitness >= worst) {
                worst = pop[i].fitness;
                worst_i = i;
            }
        }
        else {
            if (pop[i-1].fitness >= worst) {
                worst = pop[i-1].fitness;
                worst_i = i-1;
            }
            if (pop[i].fitness <= best) {
                best = pop[i].fitness;
                best_i = i;
            }
        }
    }

    if (best < pop[POPSIZE].fitness) { //a better result is found
        pop[POPSIZE] = pop[best_i];
        bestValue = pop[POPSIZE].fitness;
        bestGen = generation;      // record the bi generation
        bestEval = countEval;
        if(!flagEr && fabs(pop[POPSIZE].fitness - BESTKNOWN) < ERROR) {
            avg_err_time += finish-start;
            errGRecord[trialNum] = generation+1;
            errERecord[trialNum] = countEval;
            flagEr=true;
            successCount++;
        }
    }
    else { //no better result is found
        pop[worst_i] = pop[POPSIZE];
    }
}

void GA() {
    int i,j,fastEvalNum = 100000000;

    //---------initialize the parameters for each instance
    total_time = avg_result_time = avg_err_time=0;
    successCount=0;
    j=sizeof(evalValueAvg)/sizeof(evalValueAvg[0]);
    for(i=0;i<j;i++) evalValueAvg[i]=0;
    for(i=0;i<TRIALNUM;i++)
        errERecord[i] = errGRecord[i] = 0;

    //---------perform TRIALNUM independent runs
    for(trialNum = 0; trialNum < TRIALNUM; trialNum++) {
        bestGen = countEval = evalCount = 0;
        generation = 1;
        flagEr = false;
        start=clock();

        initialize();
        evaluate();
        keep_the_best();
        //printf("0\t%.10g\t%d\t%d\n",bestValue,bestEval,bestGen);
        while(countEval < MAXEVALS) {//while(generation<MAXGENS) {
            select_r();			//using roulette wheel selection
            crossover();
            mutate();
            evaluate();
            elitist();
            generation++;

            //	printf("%d\t%.10g\t%d\t%d\n",generation,bestValue,bestEval,bestGen);
            //	getch();
        }
        total_time += clock()-start;
        avg_result_time += finish-start;
        resultValue[trialNum] = bestValue;
        evalRecord[trialNum] = bestEval;
        genRecord[trialNum] = bestGen;

        if(bestValue>0 && bestValue<9e-323) bestValue=0;
        printf("%d\t%.10g\t%d\t%d\t%d\t%d\n",trialNum+1,bestValue,bestEval,bestGen,errERecord[trialNum],errGRecord[trialNum]);
        fprintf(filet,"%d\t%.10g\t%d\t%d\t%d\t%d\n",trialNum+1,bestValue,bestEval,bestGen,errERecord[trialNum],errGRecord[trialNum]);

        //update the global best and global worst values
        if(gbest>bestValue || (gbest==bestValue && fastEvalNum>bestEval))
        {
            gbest = bestValue;
            for(j=0; j<evalCount; j++)
                evalValueBest[j] = evalValueTemp[trialNum][j];
            if(gbest==bestValue && fastEvalNum>bestEval)
                fastEvalNum = bestEval;
        }
        if(gworst < bestValue) gworst = bestValue;
    }

    fprintf(ftotal,"%.10g\t%.10g\t",gbest,gworst);
    double sR=0.0, meanR, devR=0.0, sE=0.0, meanE, devE=0.0, sG=0.0, meanG, devG=0.0;
    double sEr=0.0, meanEr, devEr=0.0, sGr=0.0, meanGr, devGr=0.0;
    for(trialNum=0;trialNum<TRIALNUM;trialNum++) {
        sR+=resultValue[trialNum];
        sE+=evalRecord[trialNum];
        sG+=genRecord[trialNum];
        sEr+=errERecord[trialNum];
        sGr+=errGRecord[trialNum];
    }
    meanR = sR/TRIALNUM;
    meanE = sE/TRIALNUM;
    meanG = sG/TRIALNUM;
    if(successCount>0) {
        meanEr= sEr/successCount;
        meanGr= sGr/successCount;
    }
    for(trialNum=0;trialNum<TRIALNUM;trialNum++)
        devR+=pow(resultValue[trialNum]-meanR,2);
    devR/=TRIALNUM-1;
    devR=sqrt(devR);

    fprintf(ftotal,"%.10g\t%g\t%d\t%d\t%d\t%d\t%d\t%g\t%g\t%g\n",meanR,devR,
            (int)meanE,(int)meanG,(int)meanEr,(int)meanGr,
            (int)(successCount/(double)TRIALNUM*100),
            (double)total_time/(double)CLOCKS_PER_SEC/(double)TRIALNUM,
            (double)avg_result_time/(double)CLOCKS_PER_SEC/(double)TRIALNUM,
            (double)avg_err_time/(double)CLOCKS_PER_SEC/(double)successCount);

    for(i=0;i<evalCount;i++) {
        fprintf(oSAvg,"%d\t%.10g\n",evalStep*i+evalStep,evalValueAvg[i]/(double)TRIALNUM);
        fprintf(oSBest,"%d\t%.10g\n",evalStep*i+evalStep,evalValueBest[i]);
    }
}

int main()
{
    srand(time(nullptr));

    int i,j,k;
    char filename0[200],filename[200],filename1[200],filename2[200];
    char ch[50];
    strcpy(filename0,"SGA");
    itoa(NVARS,ch,10);
    strcat(filename0,ch);
    _mkdir(filename0);

    strcpy(filename1,filename0);
    strcat(filename1,"\\result.txt");
    ftotal=fopen(filename1,"a");
    fprintf(ftotal,"Fno\t[low,up]\tnvars\tpop\tpx\tpm\tTRIALNo\tmaxEval\tError\tbest\tworst\tmean\tstdev\tavgEval\tavgGen\tavgEEr\tavgGEr\t%%ok\tavgTT(sec)\tavgRT(sec)\tavgET(sec)\n");
    fclose(ftotal);

    for(i=1;i<=1;i++) {
        k=FUN_NUM[i];
        //default values
        gbest=9e+300;
        gworst=-9e+300;
        nvars = 30;
        BESTKNOWN = 0;
        evalStep=10000;

        switch(k) {
            case 1:
                objfunc=f1; MAXEVALS=1000000; break;
            case 2:
                objfunc=f2;	MAXEVALS=150000; break;
            case 3:
                objfunc=f3;	MAXEVALS=500000; break;
            case 4:
                objfunc=f4; MAXEVALS=500000; break;
            case 5:
                objfunc=f5; MAXEVALS=2000000; break;
            case 6:
                objfunc=f6; MAXEVALS=100000; evalStep=100; break;
            case 7:
                objfunc=f7; MAXEVALS=300000; evalStep=10000; break;
            case 8:
                objfunc=f8; BESTKNOWN=-12569.5*nvars/30.0; MAXEVALS=500000; break;
            case 9:
                objfunc=f9; MAXEVALS=500000; break;
            case 10:
                objfunc=f10; MAXEVALS=500000; break;
            case 11:
                objfunc=f11; MAXEVALS=500000; break;
            case 12:
                objfunc=f12; MAXEVALS=500000; break;
            case 13:
                objfunc=f13; MAXEVALS=500000; break;
            case 14:
                objfunc=f14; BESTKNOWN=0.998; nvars=2; MAXEVALS=10000; break;
            case 15:
                objfunc=f15; BESTKNOWN=0.0003074862; nvars=4; MAXEVALS=400000; break;
            case 16:
                objfunc=f16; BESTKNOWN=-1.0316285; nvars=2; MAXEVALS=10000; break;
            case 17:
                objfunc=f17; BESTKNOWN=0.397887; nvars=2; MAXEVALS=10000; break;
            case 18:
                objfunc=f18; BESTKNOWN=-10.1532; nvars=4; MAXEVALS=10000; break;
            case 19:
                objfunc=f19; BESTKNOWN=-10.40294; nvars=4; MAXEVALS=10000; break;
            case 20:
                objfunc=f20; BESTKNOWN=-10.53641; nvars=4; MAXEVALS=10000; break;
            case 21:
                objfunc=f21; BESTKNOWN=-99.2784; nvars=100; ERROR=4.7; MAXEVALS=300000; break;
            case 22:
                objfunc=f22; BESTKNOWN=-78.33236; nvars=100; ERROR=0.015; MAXEVALS=300000; break;

            default:
                printf("Cannot find f%d......\n",FUN_NUM[i]); return 0;
        }

        strcpy(filename,filename0);
        strcat(filename,"\\F");
        itoa(FUN_NUM[i],ch,10);
        strcat(filename,ch);
        _mkdir(filename);

        strcpy(filename2,filename);
        strcat(filename2,"\\stepAvg.txt");
        oSAvg=fopen(filename2,"w");
        fprintf(oSAvg,"evaluateNo\tValue\n");

        strcpy(filename2,filename);
        strcat(filename2,"\\stepB.txt");
        oSBest=fopen(filename2,"w");
        fprintf(oSBest,"evaluateNo\tValue\n");

        strcpy(filename2,filename);
        strcat(filename2,"\\total.txt");
        filet=fopen(filename2,"w");

        //read in the feasible range of variables from files
        strcpy(filename,"function\\f");
        itoa(FUN_NUM[i],ch,10);
        strcat(filename,ch);
        strcat(filename,".txt");
        if ((infile = fopen(filename, "r")) == NULL) {
            printf("Cannot open input file!\n");
            exit(1);
        }
        for(j=0;j<nvars;j++) {
            fscanf(infile, "%lf", &lB[j]);       //read in the lower boundary
            fscanf(infile, "%lf", &uB[j]);        //read in the upper boundary
        }
        fclose(infile);

        printf("\n\nFunction F%d\t[%g,%g]\n",FUN_NUM[i],lB[0],uB[0]);
        ftotal=fopen(filename1,"a");
        fprintf(ftotal,"F%d\t[%g,%g]\t%d\t%d\t%g\t%g\t%d\t%d\t%g\t",FUN_NUM[i],lB[0],uB[0],nvars,POPSIZE,PX,PM,TRIALNUM,MAXEVALS,ERROR);
        fprintf(filet,"Fno\t[low,up]\tnvars\tpop\tpx\tpm\tTRIALNo\tmaxEval\tError\n");
        fprintf(filet,"F%d\t[%g,%g]\t%d\t%d\t%g\t%g\t%d\t%d\t%g\n\n",FUN_NUM[i],lB[0],uB[0],nvars,POPSIZE,PX,PM,TRIALNUM,MAXEVALS,ERROR);
        fprintf(filet,"trial\tbest_Val\tbest_Eval\tbest_Gen\terr_Eval\terr_Gen\n");

        GA();

        fclose(ftotal);
        fclose(filet);
        fclose(oSAvg);
        fclose(oSBest);
    }

    return 0;
}